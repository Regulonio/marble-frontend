// @generated by protoc-gen-es v1.0.0 with parameter "target=ts"
// @generated from file marble.proto (syntax proto3)
/* eslint-disable */
// @ts-nocheck

import type { BinaryReadOptions, FieldList, JsonReadOptions, JsonValue, PartialMessage, PlainMessage } from "@bufbuild/protobuf";
import { Message, proto3 } from "@bufbuild/protobuf";

/**
 * @generated from enum OperatorBinary
 */
export enum OperatorBinary {
  /**
   * @generated from enum value: EQUAL = 0;
   */
  EQUAL = 0,

  /**
   * @generated from enum value: NOT_EQUAL = 1;
   */
  NOT_EQUAL = 1,

  /**
   * @generated from enum value: GREATER = 2;
   */
  GREATER = 2,

  /**
   * @generated from enum value: GREATER_EQUAL = 3;
   */
  GREATER_EQUAL = 3,

  /**
   * @generated from enum value: LOWER = 4;
   */
  LOWER = 4,

  /**
   * @generated from enum value: LOWER_EQUAL = 5;
   */
  LOWER_EQUAL = 5,

  /**
   * @generated from enum value: ADD = 6;
   */
  ADD = 6,

  /**
   * @generated from enum value: SUBTRACT = 7;
   */
  SUBTRACT = 7,

  /**
   * @generated from enum value: MULTIPLY = 8;
   */
  MULTIPLY = 8,

  /**
   * @generated from enum value: DIVIDE = 9;
   */
  DIVIDE = 9,
}
// Retrieve enum metadata with: proto3.getEnumType(OperatorBinary)
proto3.util.setEnumType(OperatorBinary, "OperatorBinary", [
  { no: 0, name: "EQUAL" },
  { no: 1, name: "NOT_EQUAL" },
  { no: 2, name: "GREATER" },
  { no: 3, name: "GREATER_EQUAL" },
  { no: 4, name: "LOWER" },
  { no: 5, name: "LOWER_EQUAL" },
  { no: 6, name: "ADD" },
  { no: 7, name: "SUBTRACT" },
  { no: 8, name: "MULTIPLY" },
  { no: 9, name: "DIVIDE" },
]);

/**
 * @generated from enum Aggregation
 */
export enum Aggregation {
  /**
   * @generated from enum value: COUNT = 0;
   */
  COUNT = 0,

  /**
   * @generated from enum value: SUM = 1;
   */
  SUM = 1,

  /**
   * @generated from enum value: MEAN = 2;
   */
  MEAN = 2,

  /**
   * @generated from enum value: MAX = 3;
   */
  MAX = 3,

  /**
   * @generated from enum value: MIN = 4;
   */
  MIN = 4,
}
// Retrieve enum metadata with: proto3.getEnumType(Aggregation)
proto3.util.setEnumType(Aggregation, "Aggregation", [
  { no: 0, name: "COUNT" },
  { no: 1, name: "SUM" },
  { no: 2, name: "MEAN" },
  { no: 3, name: "MAX" },
  { no: 4, name: "MIN" },
]);

/**
 * @generated from enum Decision
 */
export enum Decision {
  /**
   * @generated from enum value: Accept = 0;
   */
  Accept = 0,

  /**
   * @generated from enum value: Warning = 1;
   */
  Warning = 1,

  /**
   * @generated from enum value: Refuse = 2;
   */
  Refuse = 2,
}
// Retrieve enum metadata with: proto3.getEnumType(Decision)
proto3.util.setEnumType(Decision, "Decision", [
  { no: 0, name: "Accept" },
  { no: 1, name: "Warning" },
  { no: 2, name: "Refuse" },
]);

/**
 * @generated from enum DataType
 */
export enum DataType {
  /**
   * @generated from enum value: BOOL = 0;
   */
  BOOL = 0,

  /**
   * @generated from enum value: INT = 1;
   */
  INT = 1,

  /**
   * @generated from enum value: FLOAT = 2;
   */
  FLOAT = 2,

  /**
   * @generated from enum value: STRING = 3;
   */
  STRING = 3,

  /**
   * @generated from enum value: TIMESTAMP = 4;
   */
  TIMESTAMP = 4,

  /**
   * @generated from enum value: ID = 5;
   */
  ID = 5,
}
// Retrieve enum metadata with: proto3.getEnumType(DataType)
proto3.util.setEnumType(DataType, "DataType", [
  { no: 0, name: "BOOL" },
  { no: 1, name: "INT" },
  { no: 2, name: "FLOAT" },
  { no: 3, name: "STRING" },
  { no: 4, name: "TIMESTAMP" },
  { no: 5, name: "ID" },
]);

/**
 * @generated from message Scalar
 */
export class Scalar extends Message<Scalar> {
  /**
   * @generated from oneof Scalar.value
   */
  value: {
    /**
     * @generated from field: int32 int = 1;
     */
    value: number;
    case: "int";
  } | {
    /**
     * @generated from field: float float = 2;
     */
    value: number;
    case: "float";
  } | {
    /**
     * @generated from field: string string = 3;
     */
    value: string;
    case: "string";
  } | {
    /**
     * @generated from field: bool bool = 4;
     */
    value: boolean;
    case: "bool";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Scalar>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Scalar";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "int", kind: "scalar", T: 5 /* ScalarType.INT32 */, oneof: "value" },
    { no: 2, name: "float", kind: "scalar", T: 2 /* ScalarType.FLOAT */, oneof: "value" },
    { no: 3, name: "string", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
    { no: 4, name: "bool", kind: "scalar", T: 8 /* ScalarType.BOOL */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scalar {
    return new Scalar().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scalar {
    return new Scalar().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scalar {
    return new Scalar().fromJsonString(jsonString, options);
  }

  static equals(a: Scalar | PlainMessage<Scalar> | undefined, b: Scalar | PlainMessage<Scalar> | undefined): boolean {
    return proto3.util.equals(Scalar, a, b);
  }
}

/**
 * @generated from message Array
 */
export class Array extends Message<Array> {
  /**
   * @generated from oneof Array.values
   */
  values: {
    /**
     * @generated from field: Array.ArrayBool bools = 1;
     */
    value: Array_ArrayBool;
    case: "bools";
  } | {
    /**
     * @generated from field: Array.ArrayInt ints = 2;
     */
    value: Array_ArrayInt;
    case: "ints";
  } | {
    /**
     * @generated from field: Array.ArrayFloat floats = 3;
     */
    value: Array_ArrayFloat;
    case: "floats";
  } | {
    /**
     * @generated from field: Array.ArrayString strings = 4;
     */
    value: Array_ArrayString;
    case: "strings";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Array>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Array";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bools", kind: "message", T: Array_ArrayBool, oneof: "values" },
    { no: 2, name: "ints", kind: "message", T: Array_ArrayInt, oneof: "values" },
    { no: 3, name: "floats", kind: "message", T: Array_ArrayFloat, oneof: "values" },
    { no: 4, name: "strings", kind: "message", T: Array_ArrayString, oneof: "values" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Array {
    return new Array().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Array {
    return new Array().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Array {
    return new Array().fromJsonString(jsonString, options);
  }

  static equals(a: Array | PlainMessage<Array> | undefined, b: Array | PlainMessage<Array> | undefined): boolean {
    return proto3.util.equals(Array, a, b);
  }
}

/**
 * @generated from message Array.ArrayBool
 */
export class Array_ArrayBool extends Message<Array_ArrayBool> {
  /**
   * @generated from field: repeated bool bools = 1;
   */
  bools: boolean[] = [];

  constructor(data?: PartialMessage<Array_ArrayBool>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Array.ArrayBool";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "bools", kind: "scalar", T: 8 /* ScalarType.BOOL */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Array_ArrayBool {
    return new Array_ArrayBool().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Array_ArrayBool {
    return new Array_ArrayBool().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Array_ArrayBool {
    return new Array_ArrayBool().fromJsonString(jsonString, options);
  }

  static equals(a: Array_ArrayBool | PlainMessage<Array_ArrayBool> | undefined, b: Array_ArrayBool | PlainMessage<Array_ArrayBool> | undefined): boolean {
    return proto3.util.equals(Array_ArrayBool, a, b);
  }
}

/**
 * @generated from message Array.ArrayInt
 */
export class Array_ArrayInt extends Message<Array_ArrayInt> {
  /**
   * @generated from field: repeated int32 ints = 2;
   */
  ints: number[] = [];

  constructor(data?: PartialMessage<Array_ArrayInt>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Array.ArrayInt";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "ints", kind: "scalar", T: 5 /* ScalarType.INT32 */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Array_ArrayInt {
    return new Array_ArrayInt().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Array_ArrayInt {
    return new Array_ArrayInt().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Array_ArrayInt {
    return new Array_ArrayInt().fromJsonString(jsonString, options);
  }

  static equals(a: Array_ArrayInt | PlainMessage<Array_ArrayInt> | undefined, b: Array_ArrayInt | PlainMessage<Array_ArrayInt> | undefined): boolean {
    return proto3.util.equals(Array_ArrayInt, a, b);
  }
}

/**
 * @generated from message Array.ArrayFloat
 */
export class Array_ArrayFloat extends Message<Array_ArrayFloat> {
  /**
   * @generated from field: repeated float floats = 3;
   */
  floats: number[] = [];

  constructor(data?: PartialMessage<Array_ArrayFloat>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Array.ArrayFloat";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 3, name: "floats", kind: "scalar", T: 2 /* ScalarType.FLOAT */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Array_ArrayFloat {
    return new Array_ArrayFloat().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Array_ArrayFloat {
    return new Array_ArrayFloat().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Array_ArrayFloat {
    return new Array_ArrayFloat().fromJsonString(jsonString, options);
  }

  static equals(a: Array_ArrayFloat | PlainMessage<Array_ArrayFloat> | undefined, b: Array_ArrayFloat | PlainMessage<Array_ArrayFloat> | undefined): boolean {
    return proto3.util.equals(Array_ArrayFloat, a, b);
  }
}

/**
 * @generated from message Array.ArrayString
 */
export class Array_ArrayString extends Message<Array_ArrayString> {
  /**
   * @generated from field: repeated string strings = 4;
   */
  strings: string[] = [];

  constructor(data?: PartialMessage<Array_ArrayString>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Array.ArrayString";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 4, name: "strings", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Array_ArrayString {
    return new Array_ArrayString().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Array_ArrayString {
    return new Array_ArrayString().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Array_ArrayString {
    return new Array_ArrayString().fromJsonString(jsonString, options);
  }

  static equals(a: Array_ArrayString | PlainMessage<Array_ArrayString> | undefined, b: Array_ArrayString | PlainMessage<Array_ArrayString> | undefined): boolean {
    return proto3.util.equals(Array_ArrayString, a, b);
  }
}

/**
 * @generated from message ValueOrValues
 */
export class ValueOrValues extends Message<ValueOrValues> {
  /**
   * @generated from oneof ValueOrValues.value_or_values
   */
  valueOrValues: {
    /**
     * @generated from field: Scalar value = 1;
     */
    value: Scalar;
    case: "value";
  } | {
    /**
     * @generated from field: Array values = 2;
     */
    value: Array;
    case: "values";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<ValueOrValues>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "ValueOrValues";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "value", kind: "message", T: Scalar, oneof: "value_or_values" },
    { no: 2, name: "values", kind: "message", T: Array, oneof: "value_or_values" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ValueOrValues {
    return new ValueOrValues().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ValueOrValues {
    return new ValueOrValues().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ValueOrValues {
    return new ValueOrValues().fromJsonString(jsonString, options);
  }

  static equals(a: ValueOrValues | PlainMessage<ValueOrValues> | undefined, b: ValueOrValues | PlainMessage<ValueOrValues> | undefined): boolean {
    return proto3.util.equals(ValueOrValues, a, b);
  }
}

/**
 * "Column" works well for tables but is awkward when dealing with objects, "attribute" works well for objects but is awkward for tables, 
 * we chose to use "data_field" which is a good middle ground 
 *
 * @generated from message NestedDataField
 */
export class NestedDataField extends Message<NestedDataField> {
  /**
   * @generated from field: string root_table_name = 1;
   */
  rootTableName = "";

  /**
   * @generated from field: repeated string link_names = 2;
   */
  linkNames: string[] = [];

  /**
   * @generated from field: string final_data_field = 3;
   */
  finalDataField = "";

  /**
   * @generated from field: bool multiple_values = 4;
   */
  multipleValues = false;

  constructor(data?: PartialMessage<NestedDataField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "NestedDataField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "final_data_field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "multiple_values", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedDataField {
    return new NestedDataField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedDataField {
    return new NestedDataField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedDataField {
    return new NestedDataField().fromJsonString(jsonString, options);
  }

  static equals(a: NestedDataField | PlainMessage<NestedDataField> | undefined, b: NestedDataField | PlainMessage<NestedDataField> | undefined): boolean {
    return proto3.util.equals(NestedDataField, a, b);
  }
}

/**
 * @generated from message NestedVariant
 */
export class NestedVariant extends Message<NestedVariant> {
  /**
   * @generated from field: string root_table_name = 1;
   */
  rootTableName = "";

  /**
   * @generated from field: repeated string nested_data_fields = 2;
   */
  nestedDataFields: string[] = [];

  /**
   * @generated from field: string variant_field = 3;
   */
  variantField = "";

  constructor(data?: PartialMessage<NestedVariant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "NestedVariant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "nested_data_fields", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
    { no: 3, name: "variant_field", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedVariant {
    return new NestedVariant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedVariant {
    return new NestedVariant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedVariant {
    return new NestedVariant().fromJsonString(jsonString, options);
  }

  static equals(a: NestedVariant | PlainMessage<NestedVariant> | undefined, b: NestedVariant | PlainMessage<NestedVariant> | undefined): boolean {
    return proto3.util.equals(NestedVariant, a, b);
  }
}

/**
 * @generated from message AggregationEntryPoint
 */
export class AggregationEntryPoint extends Message<AggregationEntryPoint> {
  /**
   * @generated from field: string root_table_name = 1;
   */
  rootTableName = "";

  /**
   * @generated from field: repeated string link_names = 2;
   */
  linkNames: string[] = [];

  constructor(data?: PartialMessage<AggregationEntryPoint>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "AggregationEntryPoint";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "root_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_names", kind: "scalar", T: 9 /* ScalarType.STRING */, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): AggregationEntryPoint {
    return new AggregationEntryPoint().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): AggregationEntryPoint {
    return new AggregationEntryPoint().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): AggregationEntryPoint {
    return new AggregationEntryPoint().fromJsonString(jsonString, options);
  }

  static equals(a: AggregationEntryPoint | PlainMessage<AggregationEntryPoint> | undefined, b: AggregationEntryPoint | PlainMessage<AggregationEntryPoint> | undefined): boolean {
    return proto3.util.equals(AggregationEntryPoint, a, b);
  }
}

/**
 * @generated from message NestedDataFieldEvaluated
 */
export class NestedDataFieldEvaluated extends Message<NestedDataFieldEvaluated> {
  /**
   * @generated from field: NestedDataField nested_data_field = 1;
   */
  nestedDataField?: NestedDataField;

  /**
   * @generated from field: Scalar value = 2;
   */
  value?: Scalar;

  constructor(data?: PartialMessage<NestedDataFieldEvaluated>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "NestedDataFieldEvaluated";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nested_data_field", kind: "message", T: NestedDataField },
    { no: 2, name: "value", kind: "message", T: Scalar },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): NestedDataFieldEvaluated {
    return new NestedDataFieldEvaluated().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): NestedDataFieldEvaluated {
    return new NestedDataFieldEvaluated().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): NestedDataFieldEvaluated {
    return new NestedDataFieldEvaluated().fromJsonString(jsonString, options);
  }

  static equals(a: NestedDataFieldEvaluated | PlainMessage<NestedDataFieldEvaluated> | undefined, b: NestedDataFieldEvaluated | PlainMessage<NestedDataFieldEvaluated> | undefined): boolean {
    return proto3.util.equals(NestedDataFieldEvaluated, a, b);
  }
}

/**
 * @generated from message Data
 */
export class Data extends Message<Data> {
  /**
   * @generated from oneof Data.value
   */
  value: {
    /**
     * @generated from field: Scalar constant = 1;
     */
    value: Scalar;
    case: "constant";
  } | {
    /**
     * NestedDataFieldSplit nested_data_field_split = 3;
     *
     * @generated from field: NestedDataField nested_data_field = 2;
     */
    value: NestedDataField;
    case: "nestedDataField";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Data>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Data";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "constant", kind: "message", T: Scalar, oneof: "value" },
    { no: 2, name: "nested_data_field", kind: "message", T: NestedDataField, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Data {
    return new Data().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Data {
    return new Data().fromJsonString(jsonString, options);
  }

  static equals(a: Data | PlainMessage<Data> | undefined, b: Data | PlainMessage<Data> | undefined): boolean {
    return proto3.util.equals(Data, a, b);
  }
}

/**
 * @generated from message DataValue
 */
export class DataValue extends Message<DataValue> {
  /**
   * @generated from oneof DataValue.value
   */
  value: {
    /**
     * @generated from field: Scalar constant = 1;
     */
    value: Scalar;
    case: "constant";
  } | {
    /**
     * NestedDataFieldSplitEvaluated nested_data_field_split_values = 3;
     *
     * @generated from field: NestedDataFieldEvaluated nested_data_field_value = 2;
     */
    value: NestedDataFieldEvaluated;
    case: "nestedDataFieldValue";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DataValue>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "DataValue";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "constant", kind: "message", T: Scalar, oneof: "value" },
    { no: 2, name: "nested_data_field_value", kind: "message", T: NestedDataFieldEvaluated, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataValue {
    return new DataValue().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataValue {
    return new DataValue().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataValue {
    return new DataValue().fromJsonString(jsonString, options);
  }

  static equals(a: DataValue | PlainMessage<DataValue> | undefined, b: DataValue | PlainMessage<DataValue> | undefined): boolean {
    return proto3.util.equals(DataValue, a, b);
  }
}

/**
 * @generated from message OperatorUnary
 */
export class OperatorUnary extends Message<OperatorUnary> {
  constructor(data?: PartialMessage<OperatorUnary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "OperatorUnary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OperatorUnary {
    return new OperatorUnary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OperatorUnary {
    return new OperatorUnary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OperatorUnary {
    return new OperatorUnary().fromJsonString(jsonString, options);
  }

  static equals(a: OperatorUnary | PlainMessage<OperatorUnary> | undefined, b: OperatorUnary | PlainMessage<OperatorUnary> | undefined): boolean {
    return proto3.util.equals(OperatorUnary, a, b);
  }
}

/**
 * @generated from message Formula
 */
export class Formula extends Message<Formula> {
  /**
   * @generated from oneof Formula.value
   */
  value: {
    /**
     * @generated from field: Data data = 1;
     */
    value: Data;
    case: "data";
  } | {
    /**
     * @generated from field: FormulaUnary formula_unary = 2;
     */
    value: FormulaUnary;
    case: "formulaUnary";
  } | {
    /**
     * @generated from field: FormulaBinary formula_binary = 3;
     */
    value: FormulaBinary;
    case: "formulaBinary";
  } | {
    /**
     * @generated from field: FormulaAggregation formula_aggregation = 4;
     */
    value: FormulaAggregation;
    case: "formulaAggregation";
  } | {
    /**
     * @generated from field: FormulaVariant formula_variant = 5;
     */
    value: FormulaVariant;
    case: "formulaVariant";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<Formula>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Formula";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: Data, oneof: "value" },
    { no: 2, name: "formula_unary", kind: "message", T: FormulaUnary, oneof: "value" },
    { no: 3, name: "formula_binary", kind: "message", T: FormulaBinary, oneof: "value" },
    { no: 4, name: "formula_aggregation", kind: "message", T: FormulaAggregation, oneof: "value" },
    { no: 5, name: "formula_variant", kind: "message", T: FormulaVariant, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Formula {
    return new Formula().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Formula {
    return new Formula().fromJsonString(jsonString, options);
  }

  static equals(a: Formula | PlainMessage<Formula> | undefined, b: Formula | PlainMessage<Formula> | undefined): boolean {
    return proto3.util.equals(Formula, a, b);
  }
}

/**
 * @generated from message FormulaUnary
 */
export class FormulaUnary extends Message<FormulaUnary> {
  /**
   * @generated from field: Formula sub_formula = 1;
   */
  subFormula?: Formula;

  /**
   * @generated from field: OperatorUnary operator = 2;
   */
  operator?: OperatorUnary;

  constructor(data?: PartialMessage<FormulaUnary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaUnary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sub_formula", kind: "message", T: Formula },
    { no: 2, name: "operator", kind: "message", T: OperatorUnary },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaUnary {
    return new FormulaUnary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaUnary {
    return new FormulaUnary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaUnary {
    return new FormulaUnary().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaUnary | PlainMessage<FormulaUnary> | undefined, b: FormulaUnary | PlainMessage<FormulaUnary> | undefined): boolean {
    return proto3.util.equals(FormulaUnary, a, b);
  }
}

/**
 * @generated from message FormulaBinary
 */
export class FormulaBinary extends Message<FormulaBinary> {
  /**
   * @generated from field: Formula left = 1;
   */
  left?: Formula;

  /**
   * @generated from field: OperatorBinary operator = 2;
   */
  operator = OperatorBinary.EQUAL;

  /**
   * @generated from field: Formula right = 3;
   */
  right?: Formula;

  constructor(data?: PartialMessage<FormulaBinary>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaBinary";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: Formula },
    { no: 2, name: "operator", kind: "enum", T: proto3.getEnumType(OperatorBinary) },
    { no: 3, name: "right", kind: "message", T: Formula },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaBinary {
    return new FormulaBinary().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaBinary {
    return new FormulaBinary().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaBinary {
    return new FormulaBinary().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaBinary | PlainMessage<FormulaBinary> | undefined, b: FormulaBinary | PlainMessage<FormulaBinary> | undefined): boolean {
    return proto3.util.equals(FormulaBinary, a, b);
  }
}

/**
 * @generated from message FormulaFilter
 */
export class FormulaFilter extends Message<FormulaFilter> {
  /**
   * @generated from field: Formula condition = 1;
   */
  condition?: Formula;

  constructor(data?: PartialMessage<FormulaFilter>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaFilter";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "condition", kind: "message", T: Formula },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaFilter {
    return new FormulaFilter().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaFilter {
    return new FormulaFilter().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaFilter {
    return new FormulaFilter().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaFilter | PlainMessage<FormulaFilter> | undefined, b: FormulaFilter | PlainMessage<FormulaFilter> | undefined): boolean {
    return proto3.util.equals(FormulaFilter, a, b);
  }
}

/**
 * @generated from message FormulaAggregation
 */
export class FormulaAggregation extends Message<FormulaAggregation> {
  /**
   * @generated from field: AggregationEntryPoint aggregation_entry_point = 1;
   */
  aggregationEntryPoint?: AggregationEntryPoint;

  /**
   * @generated from field: repeated Formula filters = 2;
   */
  filters: Formula[] = [];

  /**
   * @generated from field: Formula sub_formula = 3;
   */
  subFormula?: Formula;

  /**
   * @generated from field: Aggregation aggregation = 4;
   */
  aggregation = Aggregation.COUNT;

  constructor(data?: PartialMessage<FormulaAggregation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaAggregation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "aggregation_entry_point", kind: "message", T: AggregationEntryPoint },
    { no: 2, name: "filters", kind: "message", T: Formula, repeated: true },
    { no: 3, name: "sub_formula", kind: "message", T: Formula },
    { no: 4, name: "aggregation", kind: "enum", T: proto3.getEnumType(Aggregation) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaAggregation {
    return new FormulaAggregation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaAggregation {
    return new FormulaAggregation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaAggregation {
    return new FormulaAggregation().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaAggregation | PlainMessage<FormulaAggregation> | undefined, b: FormulaAggregation | PlainMessage<FormulaAggregation> | undefined): boolean {
    return proto3.util.equals(FormulaAggregation, a, b);
  }
}

/**
 * @generated from message FormulaVariant
 */
export class FormulaVariant extends Message<FormulaVariant> {
  /**
   * @generated from field: NestedVariant variant_field = 1;
   */
  variantField?: NestedVariant;

  /**
   * @generated from field: map<string, Formula> cases = 2;
   */
  cases: { [key: string]: Formula } = {};

  constructor(data?: PartialMessage<FormulaVariant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaVariant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "variant_field", kind: "message", T: NestedVariant },
    { no: 2, name: "cases", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: Formula} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaVariant {
    return new FormulaVariant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaVariant {
    return new FormulaVariant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaVariant {
    return new FormulaVariant().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaVariant | PlainMessage<FormulaVariant> | undefined, b: FormulaVariant | PlainMessage<FormulaVariant> | undefined): boolean {
    return proto3.util.equals(FormulaVariant, a, b);
  }
}

/**
 * @generated from message FormulaSelect
 */
export class FormulaSelect extends Message<FormulaSelect> {
  /**
   * @generated from field: Formula formula_selection_criterion = 1;
   */
  formulaSelectionCriterion?: Formula;

  /**
   * @generated from field: bool select_max = 2;
   */
  selectMax = false;

  /**
   * @generated from field: Formula formula_on_selected = 3;
   */
  formulaOnSelected?: Formula;

  constructor(data?: PartialMessage<FormulaSelect>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaSelect";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "formula_selection_criterion", kind: "message", T: Formula },
    { no: 2, name: "select_max", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 3, name: "formula_on_selected", kind: "message", T: Formula },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaSelect {
    return new FormulaSelect().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaSelect {
    return new FormulaSelect().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaSelect {
    return new FormulaSelect().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaSelect | PlainMessage<FormulaSelect> | undefined, b: FormulaSelect | PlainMessage<FormulaSelect> | undefined): boolean {
    return proto3.util.equals(FormulaSelect, a, b);
  }
}

/**
 * @generated from message FormulaEvaluation
 */
export class FormulaEvaluation extends Message<FormulaEvaluation> {
  /**
   * @generated from oneof FormulaEvaluation.value
   */
  value: {
    /**
     * @generated from field: DataValue data = 1;
     */
    value: DataValue;
    case: "data";
  } | {
    /**
     * @generated from field: FormulaUnaryEvaluation unary = 2;
     */
    value: FormulaUnaryEvaluation;
    case: "unary";
  } | {
    /**
     * @generated from field: FormulaBinaryEvaluation binary = 3;
     */
    value: FormulaBinaryEvaluation;
    case: "binary";
  } | {
    /**
     * @generated from field: FormulaAggregationEvaluation aggregation = 4;
     */
    value: FormulaAggregationEvaluation;
    case: "aggregation";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<FormulaEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data", kind: "message", T: DataValue, oneof: "value" },
    { no: 2, name: "unary", kind: "message", T: FormulaUnaryEvaluation, oneof: "value" },
    { no: 3, name: "binary", kind: "message", T: FormulaBinaryEvaluation, oneof: "value" },
    { no: 4, name: "aggregation", kind: "message", T: FormulaAggregationEvaluation, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaEvaluation {
    return new FormulaEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaEvaluation {
    return new FormulaEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaEvaluation {
    return new FormulaEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaEvaluation | PlainMessage<FormulaEvaluation> | undefined, b: FormulaEvaluation | PlainMessage<FormulaEvaluation> | undefined): boolean {
    return proto3.util.equals(FormulaEvaluation, a, b);
  }
}

/**
 * @generated from message FormulaUnaryEvaluation
 */
export class FormulaUnaryEvaluation extends Message<FormulaUnaryEvaluation> {
  /**
   * @generated from field: FormulaEvaluation sub_formula = 1;
   */
  subFormula?: FormulaEvaluation;

  /**
   * @generated from field: OperatorUnary operator = 2;
   */
  operator?: OperatorUnary;

  /**
   * @generated from field: ValueOrValues evaluation = 3;
   */
  evaluation?: ValueOrValues;

  constructor(data?: PartialMessage<FormulaUnaryEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaUnaryEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sub_formula", kind: "message", T: FormulaEvaluation },
    { no: 2, name: "operator", kind: "message", T: OperatorUnary },
    { no: 3, name: "evaluation", kind: "message", T: ValueOrValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaUnaryEvaluation {
    return new FormulaUnaryEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaUnaryEvaluation {
    return new FormulaUnaryEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaUnaryEvaluation {
    return new FormulaUnaryEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaUnaryEvaluation | PlainMessage<FormulaUnaryEvaluation> | undefined, b: FormulaUnaryEvaluation | PlainMessage<FormulaUnaryEvaluation> | undefined): boolean {
    return proto3.util.equals(FormulaUnaryEvaluation, a, b);
  }
}

/**
 * @generated from message FormulaBinaryEvaluation
 */
export class FormulaBinaryEvaluation extends Message<FormulaBinaryEvaluation> {
  /**
   * @generated from field: FormulaEvaluation left = 1;
   */
  left?: FormulaEvaluation;

  /**
   * @generated from field: OperatorBinary operator = 2;
   */
  operator = OperatorBinary.EQUAL;

  /**
   * @generated from field: FormulaEvaluation right = 3;
   */
  right?: FormulaEvaluation;

  /**
   * @generated from field: ValueOrValues evaluation = 4;
   */
  evaluation?: ValueOrValues;

  constructor(data?: PartialMessage<FormulaBinaryEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaBinaryEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "left", kind: "message", T: FormulaEvaluation },
    { no: 2, name: "operator", kind: "enum", T: proto3.getEnumType(OperatorBinary) },
    { no: 3, name: "right", kind: "message", T: FormulaEvaluation },
    { no: 4, name: "evaluation", kind: "message", T: ValueOrValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaBinaryEvaluation {
    return new FormulaBinaryEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaBinaryEvaluation {
    return new FormulaBinaryEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaBinaryEvaluation {
    return new FormulaBinaryEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaBinaryEvaluation | PlainMessage<FormulaBinaryEvaluation> | undefined, b: FormulaBinaryEvaluation | PlainMessage<FormulaBinaryEvaluation> | undefined): boolean {
    return proto3.util.equals(FormulaBinaryEvaluation, a, b);
  }
}

/**
 * @generated from message FormulaAggregationEvaluation
 */
export class FormulaAggregationEvaluation extends Message<FormulaAggregationEvaluation> {
  /**
   * @generated from field: FormulaEvaluation sub_formula = 1;
   */
  subFormula?: FormulaEvaluation;

  /**
   * @generated from field: Aggregation aggregation = 2;
   */
  aggregation = Aggregation.COUNT;

  /**
   * @generated from field: ValueOrValues evaluation = 3;
   */
  evaluation?: ValueOrValues;

  constructor(data?: PartialMessage<FormulaAggregationEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "FormulaAggregationEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "sub_formula", kind: "message", T: FormulaEvaluation },
    { no: 2, name: "aggregation", kind: "enum", T: proto3.getEnumType(Aggregation) },
    { no: 3, name: "evaluation", kind: "message", T: ValueOrValues },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): FormulaAggregationEvaluation {
    return new FormulaAggregationEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): FormulaAggregationEvaluation {
    return new FormulaAggregationEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): FormulaAggregationEvaluation {
    return new FormulaAggregationEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: FormulaAggregationEvaluation | PlainMessage<FormulaAggregationEvaluation> | undefined, b: FormulaAggregationEvaluation | PlainMessage<FormulaAggregationEvaluation> | undefined): boolean {
    return proto3.util.equals(FormulaAggregationEvaluation, a, b);
  }
}

/**
 * @generated from message Scope
 */
export class Scope extends Message<Scope> {
  /**
   * @generated from field: repeated Formula conditions = 1;
   */
  conditions: Formula[] = [];

  constructor(data?: PartialMessage<Scope>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Scope";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: Formula, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Scope {
    return new Scope().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Scope {
    return new Scope().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Scope {
    return new Scope().fromJsonString(jsonString, options);
  }

  static equals(a: Scope | PlainMessage<Scope> | undefined, b: Scope | PlainMessage<Scope> | undefined): boolean {
    return proto3.util.equals(Scope, a, b);
  }
}

/**
 * @generated from message ScopeEvaluation
 */
export class ScopeEvaluation extends Message<ScopeEvaluation> {
  /**
   * @generated from field: repeated FormulaEvaluation conditions = 1;
   */
  conditions: FormulaEvaluation[] = [];

  /**
   * @generated from field: bool result = 2;
   */
  result = false;

  constructor(data?: PartialMessage<ScopeEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "ScopeEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: FormulaEvaluation, repeated: true },
    { no: 2, name: "result", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScopeEvaluation {
    return new ScopeEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScopeEvaluation {
    return new ScopeEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScopeEvaluation {
    return new ScopeEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: ScopeEvaluation | PlainMessage<ScopeEvaluation> | undefined, b: ScopeEvaluation | PlainMessage<ScopeEvaluation> | undefined): boolean {
    return proto3.util.equals(ScopeEvaluation, a, b);
  }
}

/**
 * @generated from message Consequence
 */
export class Consequence extends Message<Consequence> {
  /**
   * @generated from field: optional int32 score_increase = 1;
   */
  scoreIncrease?: number;

  /**
   * @generated from field: optional Decision decision = 2;
   */
  decision?: Decision;

  constructor(data?: PartialMessage<Consequence>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Consequence";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "score_increase", kind: "scalar", T: 5 /* ScalarType.INT32 */, opt: true },
    { no: 2, name: "decision", kind: "enum", T: proto3.getEnumType(Decision), opt: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Consequence {
    return new Consequence().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Consequence {
    return new Consequence().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Consequence {
    return new Consequence().fromJsonString(jsonString, options);
  }

  static equals(a: Consequence | PlainMessage<Consequence> | undefined, b: Consequence | PlainMessage<Consequence> | undefined): boolean {
    return proto3.util.equals(Consequence, a, b);
  }
}

/**
 * @generated from message OrGroup
 */
export class OrGroup extends Message<OrGroup> {
  /**
   * @generated from field: repeated Formula conditions = 1;
   */
  conditions: Formula[] = [];

  constructor(data?: PartialMessage<OrGroup>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "OrGroup";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: Formula, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrGroup {
    return new OrGroup().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrGroup {
    return new OrGroup().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrGroup {
    return new OrGroup().fromJsonString(jsonString, options);
  }

  static equals(a: OrGroup | PlainMessage<OrGroup> | undefined, b: OrGroup | PlainMessage<OrGroup> | undefined): boolean {
    return proto3.util.equals(OrGroup, a, b);
  }
}

/**
 * @generated from message OrGroupEvaluation
 */
export class OrGroupEvaluation extends Message<OrGroupEvaluation> {
  /**
   * @generated from field: repeated FormulaEvaluation conditions = 1;
   */
  conditions: FormulaEvaluation[] = [];

  /**
   * @generated from field: bool result = 2;
   */
  result = false;

  constructor(data?: PartialMessage<OrGroupEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "OrGroupEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "conditions", kind: "message", T: FormulaEvaluation, repeated: true },
    { no: 2, name: "result", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): OrGroupEvaluation {
    return new OrGroupEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): OrGroupEvaluation {
    return new OrGroupEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): OrGroupEvaluation {
    return new OrGroupEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: OrGroupEvaluation | PlainMessage<OrGroupEvaluation> | undefined, b: OrGroupEvaluation | PlainMessage<OrGroupEvaluation> | undefined): boolean {
    return proto3.util.equals(OrGroupEvaluation, a, b);
  }
}

/**
 * @generated from message Rule
 */
export class Rule extends Message<Rule> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: repeated OrGroup or_groups = 2;
   */
  orGroups: OrGroup[] = [];

  /**
   * @generated from field: Consequence consequence = 3;
   */
  consequence?: Consequence;

  constructor(data?: PartialMessage<Rule>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Rule";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "or_groups", kind: "message", T: OrGroup, repeated: true },
    { no: 3, name: "consequence", kind: "message", T: Consequence },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Rule {
    return new Rule().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Rule {
    return new Rule().fromJsonString(jsonString, options);
  }

  static equals(a: Rule | PlainMessage<Rule> | undefined, b: Rule | PlainMessage<Rule> | undefined): boolean {
    return proto3.util.equals(Rule, a, b);
  }
}

/**
 * @generated from message RuleEvaluation
 */
export class RuleEvaluation extends Message<RuleEvaluation> {
  /**
   * @generated from field: repeated OrGroupEvaluation or_groups = 1;
   */
  orGroups: OrGroupEvaluation[] = [];

  /**
   * @generated from field: Consequence consequence = 3;
   */
  consequence?: Consequence;

  /**
   * @generated from field: bool result = 4;
   */
  result = false;

  constructor(data?: PartialMessage<RuleEvaluation>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RuleEvaluation";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "or_groups", kind: "message", T: OrGroupEvaluation, repeated: true },
    { no: 3, name: "consequence", kind: "message", T: Consequence },
    { no: 4, name: "result", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RuleEvaluation {
    return new RuleEvaluation().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RuleEvaluation {
    return new RuleEvaluation().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RuleEvaluation {
    return new RuleEvaluation().fromJsonString(jsonString, options);
  }

  static equals(a: RuleEvaluation | PlainMessage<RuleEvaluation> | undefined, b: RuleEvaluation | PlainMessage<RuleEvaluation> | undefined): boolean {
    return proto3.util.equals(RuleEvaluation, a, b);
  }
}

/**
 * @generated from message Trigger
 */
export class Trigger extends Message<Trigger> {
  constructor(data?: PartialMessage<Trigger>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Trigger";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Trigger {
    return new Trigger().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Trigger {
    return new Trigger().fromJsonString(jsonString, options);
  }

  static equals(a: Trigger | PlainMessage<Trigger> | undefined, b: Trigger | PlainMessage<Trigger> | undefined): boolean {
    return proto3.util.equals(Trigger, a, b);
  }
}

/**
 * @generated from message ScenarioVersionBody
 */
export class ScenarioVersionBody extends Message<ScenarioVersionBody> {
  /**
   * @generated from field: Scope scope = 2;
   */
  scope?: Scope;

  /**
   * @generated from field: repeated Rule rules = 3;
   */
  rules: Rule[] = [];

  constructor(data?: PartialMessage<ScenarioVersionBody>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "ScenarioVersionBody";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 2, name: "scope", kind: "message", T: Scope },
    { no: 3, name: "rules", kind: "message", T: Rule, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScenarioVersionBody {
    return new ScenarioVersionBody().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScenarioVersionBody {
    return new ScenarioVersionBody().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScenarioVersionBody {
    return new ScenarioVersionBody().fromJsonString(jsonString, options);
  }

  static equals(a: ScenarioVersionBody | PlainMessage<ScenarioVersionBody> | undefined, b: ScenarioVersionBody | PlainMessage<ScenarioVersionBody> | undefined): boolean {
    return proto3.util.equals(ScenarioVersionBody, a, b);
  }
}

/**
 * @generated from message ScenarioResult
 */
export class ScenarioResult extends Message<ScenarioResult> {
  /**
   * @generated from field: string id = 1;
   */
  id = "";

  /**
   * @generated from field: ScopeEvaluation scope = 2;
   */
  scope?: ScopeEvaluation;

  /**
   * @generated from field: repeated RuleEvaluation rules = 3;
   */
  rules: RuleEvaluation[] = [];

  /**
   * @generated from field: Consequence consequence = 4;
   */
  consequence?: Consequence;

  constructor(data?: PartialMessage<ScenarioResult>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "ScenarioResult";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "id", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "scope", kind: "message", T: ScopeEvaluation },
    { no: 3, name: "rules", kind: "message", T: RuleEvaluation, repeated: true },
    { no: 4, name: "consequence", kind: "message", T: Consequence },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): ScenarioResult {
    return new ScenarioResult().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): ScenarioResult {
    return new ScenarioResult().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): ScenarioResult {
    return new ScenarioResult().fromJsonString(jsonString, options);
  }

  static equals(a: ScenarioResult | PlainMessage<ScenarioResult> | undefined, b: ScenarioResult | PlainMessage<ScenarioResult> | undefined): boolean {
    return proto3.util.equals(ScenarioResult, a, b);
  }
}

/**
 * @generated from message DataField
 */
export class DataField extends Message<DataField> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: DataType data_type = 2;
   */
  dataType = DataType.BOOL;

  constructor(data?: PartialMessage<DataField>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "DataField";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "data_type", kind: "enum", T: proto3.getEnumType(DataType) },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataField {
    return new DataField().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataField {
    return new DataField().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataField {
    return new DataField().fromJsonString(jsonString, options);
  }

  static equals(a: DataField | PlainMessage<DataField> | undefined, b: DataField | PlainMessage<DataField> | undefined): boolean {
    return proto3.util.equals(DataField, a, b);
  }
}

/**
 * @generated from message DataFieldOrTable
 */
export class DataFieldOrTable extends Message<DataFieldOrTable> {
  /**
   * @generated from oneof DataFieldOrTable.value
   */
  value: {
    /**
     * @generated from field: DataField data_field = 1;
     */
    value: DataField;
    case: "dataField";
  } | {
    /**
     * join_column_name is the key in variant, maybe reciprocal attribute name
     *
     * @generated from field: string table_name = 2;
     */
    value: string;
    case: "tableName";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DataFieldOrTable>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "DataFieldOrTable";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_field", kind: "message", T: DataField, oneof: "value" },
    { no: 2, name: "table_name", kind: "scalar", T: 9 /* ScalarType.STRING */, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataFieldOrTable {
    return new DataFieldOrTable().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataFieldOrTable {
    return new DataFieldOrTable().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataFieldOrTable {
    return new DataFieldOrTable().fromJsonString(jsonString, options);
  }

  static equals(a: DataFieldOrTable | PlainMessage<DataFieldOrTable> | undefined, b: DataFieldOrTable | PlainMessage<DataFieldOrTable> | undefined): boolean {
    return proto3.util.equals(DataFieldOrTable, a, b);
  }
}

/**
 * @generated from message Variant
 */
export class Variant extends Message<Variant> {
  /**
   * @generated from field: bool nullable = 1;
   */
  nullable = false;

  /**
   * @generated from field: map<string, DataFieldOrTable> cases = 2;
   */
  cases: { [key: string]: DataFieldOrTable } = {};

  constructor(data?: PartialMessage<Variant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "Variant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "nullable", kind: "scalar", T: 8 /* ScalarType.BOOL */ },
    { no: 2, name: "cases", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: DataFieldOrTable} },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): Variant {
    return new Variant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): Variant {
    return new Variant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): Variant {
    return new Variant().fromJsonString(jsonString, options);
  }

  static equals(a: Variant | PlainMessage<Variant> | undefined, b: Variant | PlainMessage<Variant> | undefined): boolean {
    return proto3.util.equals(Variant, a, b);
  }
}

/**
 * @generated from message DataFieldOrVariant
 */
export class DataFieldOrVariant extends Message<DataFieldOrVariant> {
  /**
   * @generated from oneof DataFieldOrVariant.value
   */
  value: {
    /**
     * @generated from field: DataField data_field = 1;
     */
    value: DataField;
    case: "dataField";
  } | {
    /**
     * @generated from field: Variant variant = 2;
     */
    value: Variant;
    case: "variant";
  } | { case: undefined; value?: undefined } = { case: undefined };

  constructor(data?: PartialMessage<DataFieldOrVariant>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "DataFieldOrVariant";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "data_field", kind: "message", T: DataField, oneof: "value" },
    { no: 2, name: "variant", kind: "message", T: Variant, oneof: "value" },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): DataFieldOrVariant {
    return new DataFieldOrVariant().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): DataFieldOrVariant {
    return new DataFieldOrVariant().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): DataFieldOrVariant {
    return new DataFieldOrVariant().fromJsonString(jsonString, options);
  }

  static equals(a: DataFieldOrVariant | PlainMessage<DataFieldOrVariant> | undefined, b: DataFieldOrVariant | PlainMessage<DataFieldOrVariant> | undefined): boolean {
    return proto3.util.equals(DataFieldOrVariant, a, b);
  }
}

/**
 * @generated from message RelationshipOneToOneHomogeneousSymmetric
 */
export class RelationshipOneToOneHomogeneousSymmetric extends Message<RelationshipOneToOneHomogeneousSymmetric> {
  /**
   * @generated from field: string join_column_name = 1;
   */
  joinColumnName = "";

  /**
   * @generated from field: string link_name = 2;
   */
  linkName = "";

  constructor(data?: PartialMessage<RelationshipOneToOneHomogeneousSymmetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipOneToOneHomogeneousSymmetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "join_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipOneToOneHomogeneousSymmetric {
    return new RelationshipOneToOneHomogeneousSymmetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipOneToOneHomogeneousSymmetric {
    return new RelationshipOneToOneHomogeneousSymmetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipOneToOneHomogeneousSymmetric {
    return new RelationshipOneToOneHomogeneousSymmetric().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipOneToOneHomogeneousSymmetric | PlainMessage<RelationshipOneToOneHomogeneousSymmetric> | undefined, b: RelationshipOneToOneHomogeneousSymmetric | PlainMessage<RelationshipOneToOneHomogeneousSymmetric> | undefined): boolean {
    return proto3.util.equals(RelationshipOneToOneHomogeneousSymmetric, a, b);
  }
}

/**
 * @generated from message RelationshipOneToOneHomogeneousAsymmetric
 */
export class RelationshipOneToOneHomogeneousAsymmetric extends Message<RelationshipOneToOneHomogeneousAsymmetric> {
  /**
   * @generated from field: string join_column_name = 1;
   */
  joinColumnName = "";

  /**
   * @generated from field: string link_name_direct = 2;
   */
  linkNameDirect = "";

  /**
   * @generated from field: string link_name_reverse = 3;
   */
  linkNameReverse = "";

  constructor(data?: PartialMessage<RelationshipOneToOneHomogeneousAsymmetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipOneToOneHomogeneousAsymmetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "join_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_name_direct", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "link_name_reverse", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipOneToOneHomogeneousAsymmetric {
    return new RelationshipOneToOneHomogeneousAsymmetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipOneToOneHomogeneousAsymmetric {
    return new RelationshipOneToOneHomogeneousAsymmetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipOneToOneHomogeneousAsymmetric {
    return new RelationshipOneToOneHomogeneousAsymmetric().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipOneToOneHomogeneousAsymmetric | PlainMessage<RelationshipOneToOneHomogeneousAsymmetric> | undefined, b: RelationshipOneToOneHomogeneousAsymmetric | PlainMessage<RelationshipOneToOneHomogeneousAsymmetric> | undefined): boolean {
    return proto3.util.equals(RelationshipOneToOneHomogeneousAsymmetric, a, b);
  }
}

/**
 * @generated from message RelationshipOneToManyHomogeneous
 */
export class RelationshipOneToManyHomogeneous extends Message<RelationshipOneToManyHomogeneous> {
  /**
   * @generated from field: string children_join_column_name = 1;
   */
  childrenJoinColumnName = "";

  /**
   * @generated from field: string link_name_parent_to_children = 2;
   */
  linkNameParentToChildren = "";

  /**
   * @generated from field: string link_name_children_to_parent = 3;
   */
  linkNameChildrenToParent = "";

  constructor(data?: PartialMessage<RelationshipOneToManyHomogeneous>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipOneToManyHomogeneous";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "children_join_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "link_name_parent_to_children", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "link_name_children_to_parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipOneToManyHomogeneous {
    return new RelationshipOneToManyHomogeneous().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipOneToManyHomogeneous {
    return new RelationshipOneToManyHomogeneous().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipOneToManyHomogeneous {
    return new RelationshipOneToManyHomogeneous().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipOneToManyHomogeneous | PlainMessage<RelationshipOneToManyHomogeneous> | undefined, b: RelationshipOneToManyHomogeneous | PlainMessage<RelationshipOneToManyHomogeneous> | undefined): boolean {
    return proto3.util.equals(RelationshipOneToManyHomogeneous, a, b);
  }
}

/**
 * @generated from message RelationshipManyToManyHomogeneousSymmetric
 */
export class RelationshipManyToManyHomogeneousSymmetric extends Message<RelationshipManyToManyHomogeneousSymmetric> {
  /**
   * @generated from field: string association_table_name = 1;
   */
  associationTableName = "";

  /**
   * @generated from field: string column_name_to_join_on_left = 2;
   */
  columnNameToJoinOnLeft = "";

  /**
   * @generated from field: string column_name_to_join_on_right = 3;
   */
  columnNameToJoinOnRight = "";

  /**
   * @generated from field: string link_name = 4;
   */
  linkName = "";

  constructor(data?: PartialMessage<RelationshipManyToManyHomogeneousSymmetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipManyToManyHomogeneousSymmetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "association_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_name_to_join_on_left", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column_name_to_join_on_right", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "link_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipManyToManyHomogeneousSymmetric {
    return new RelationshipManyToManyHomogeneousSymmetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipManyToManyHomogeneousSymmetric {
    return new RelationshipManyToManyHomogeneousSymmetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipManyToManyHomogeneousSymmetric {
    return new RelationshipManyToManyHomogeneousSymmetric().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipManyToManyHomogeneousSymmetric | PlainMessage<RelationshipManyToManyHomogeneousSymmetric> | undefined, b: RelationshipManyToManyHomogeneousSymmetric | PlainMessage<RelationshipManyToManyHomogeneousSymmetric> | undefined): boolean {
    return proto3.util.equals(RelationshipManyToManyHomogeneousSymmetric, a, b);
  }
}

/**
 * @generated from message RelationshipManyToManyHomogeneousAsymmetric
 */
export class RelationshipManyToManyHomogeneousAsymmetric extends Message<RelationshipManyToManyHomogeneousAsymmetric> {
  /**
   * @generated from field: string association_table_name = 1;
   */
  associationTableName = "";

  /**
   * @generated from field: string column_name_to_join_on_left = 2;
   */
  columnNameToJoinOnLeft = "";

  /**
   * @generated from field: string column_name_to_join_on_right = 3;
   */
  columnNameToJoinOnRight = "";

  /**
   * @generated from field: string link_name_table_left_to_table_right = 4;
   */
  linkNameTableLeftToTableRight = "";

  /**
   * @generated from field: string link_name_table_right_to_table_left = 5;
   */
  linkNameTableRightToTableLeft = "";

  constructor(data?: PartialMessage<RelationshipManyToManyHomogeneousAsymmetric>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipManyToManyHomogeneousAsymmetric";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "association_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "column_name_to_join_on_left", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "column_name_to_join_on_right", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "link_name_table_left_to_table_right", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "link_name_table_right_to_table_left", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipManyToManyHomogeneousAsymmetric {
    return new RelationshipManyToManyHomogeneousAsymmetric().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipManyToManyHomogeneousAsymmetric {
    return new RelationshipManyToManyHomogeneousAsymmetric().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipManyToManyHomogeneousAsymmetric {
    return new RelationshipManyToManyHomogeneousAsymmetric().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipManyToManyHomogeneousAsymmetric | PlainMessage<RelationshipManyToManyHomogeneousAsymmetric> | undefined, b: RelationshipManyToManyHomogeneousAsymmetric | PlainMessage<RelationshipManyToManyHomogeneousAsymmetric> | undefined): boolean {
    return proto3.util.equals(RelationshipManyToManyHomogeneousAsymmetric, a, b);
  }
}

/**
 * @generated from message TableStructure
 */
export class TableStructure extends Message<TableStructure> {
  /**
   * @generated from field: string name = 1;
   */
  name = "";

  /**
   * @generated from field: map<string, DataField> columns = 2;
   */
  columns: { [key: string]: DataField } = {};

  /**
   * @generated from field: repeated RelationshipOneToOneHomogeneousAsymmetric relationships_one_to_one_asymmetric = 3;
   */
  relationshipsOneToOneAsymmetric: RelationshipOneToOneHomogeneousAsymmetric[] = [];

  /**
   * @generated from field: repeated RelationshipOneToOneHomogeneousSymmetric relationships_one_to_one_symmetric = 4;
   */
  relationshipsOneToOneSymmetric: RelationshipOneToOneHomogeneousSymmetric[] = [];

  /**
   * @generated from field: repeated RelationshipOneToManyHomogeneous relationships_one_to_many = 5;
   */
  relationshipsOneToMany: RelationshipOneToManyHomogeneous[] = [];

  /**
   * @generated from field: repeated RelationshipManyToManyHomogeneousAsymmetric relationships_many_to_many_asymmetric = 6;
   */
  relationshipsManyToManyAsymmetric: RelationshipManyToManyHomogeneousAsymmetric[] = [];

  /**
   * @generated from field: repeated RelationshipManyToManyHomogeneousSymmetric relationships_many_to_many_symmetric = 7;
   */
  relationshipsManyToManySymmetric: RelationshipManyToManyHomogeneousSymmetric[] = [];

  constructor(data?: PartialMessage<TableStructure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "TableStructure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "columns", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: DataField} },
    { no: 3, name: "relationships_one_to_one_asymmetric", kind: "message", T: RelationshipOneToOneHomogeneousAsymmetric, repeated: true },
    { no: 4, name: "relationships_one_to_one_symmetric", kind: "message", T: RelationshipOneToOneHomogeneousSymmetric, repeated: true },
    { no: 5, name: "relationships_one_to_many", kind: "message", T: RelationshipOneToManyHomogeneous, repeated: true },
    { no: 6, name: "relationships_many_to_many_asymmetric", kind: "message", T: RelationshipManyToManyHomogeneousAsymmetric, repeated: true },
    { no: 7, name: "relationships_many_to_many_symmetric", kind: "message", T: RelationshipManyToManyHomogeneousSymmetric, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): TableStructure {
    return new TableStructure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): TableStructure {
    return new TableStructure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): TableStructure {
    return new TableStructure().fromJsonString(jsonString, options);
  }

  static equals(a: TableStructure | PlainMessage<TableStructure> | undefined, b: TableStructure | PlainMessage<TableStructure> | undefined): boolean {
    return proto3.util.equals(TableStructure, a, b);
  }
}

/**
 * @generated from message RelationshipOneToOne
 */
export class RelationshipOneToOne extends Message<RelationshipOneToOne> {
  /**
   * @generated from field: string table_containing_join_column = 1;
   */
  tableContainingJoinColumn = "";

  /**
   * @generated from field: string join_column_name = 2;
   */
  joinColumnName = "";

  /**
   * @generated from field: string table_referenced = 3;
   */
  tableReferenced = "";

  /**
   * @generated from field: string link_name_table_containing_join_column_to_table_referenced = 4;
   */
  linkNameTableContainingJoinColumnToTableReferenced = "";

  /**
   * @generated from field: string link_name_table_referenced_to_table_containing_join_column = 5;
   */
  linkNameTableReferencedToTableContainingJoinColumn = "";

  constructor(data?: PartialMessage<RelationshipOneToOne>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipOneToOne";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_containing_join_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "join_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "table_referenced", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "link_name_table_containing_join_column_to_table_referenced", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "link_name_table_referenced_to_table_containing_join_column", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipOneToOne {
    return new RelationshipOneToOne().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipOneToOne {
    return new RelationshipOneToOne().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipOneToOne {
    return new RelationshipOneToOne().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipOneToOne | PlainMessage<RelationshipOneToOne> | undefined, b: RelationshipOneToOne | PlainMessage<RelationshipOneToOne> | undefined): boolean {
    return proto3.util.equals(RelationshipOneToOne, a, b);
  }
}

/**
 * @generated from message RelationshipOneToMany
 */
export class RelationshipOneToMany extends Message<RelationshipOneToMany> {
  /**
   * @generated from field: string parent_table_name = 1;
   */
  parentTableName = "";

  /**
   * @generated from field: string children_table_name = 2;
   */
  childrenTableName = "";

  /**
   * @generated from field: string children_join_column_name = 3;
   */
  childrenJoinColumnName = "";

  /**
   * @generated from field: string link_name_parent_to_children = 4;
   */
  linkNameParentToChildren = "";

  /**
   * @generated from field: string link_name_children_to_parent = 5;
   */
  linkNameChildrenToParent = "";

  constructor(data?: PartialMessage<RelationshipOneToMany>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipOneToMany";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "parent_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "children_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "children_join_column_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "link_name_parent_to_children", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "link_name_children_to_parent", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipOneToMany {
    return new RelationshipOneToMany().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipOneToMany {
    return new RelationshipOneToMany().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipOneToMany {
    return new RelationshipOneToMany().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipOneToMany | PlainMessage<RelationshipOneToMany> | undefined, b: RelationshipOneToMany | PlainMessage<RelationshipOneToMany> | undefined): boolean {
    return proto3.util.equals(RelationshipOneToMany, a, b);
  }
}

/**
 * @generated from message RelationshipManyToMany
 */
export class RelationshipManyToMany extends Message<RelationshipManyToMany> {
  /**
   * @generated from field: string table_left_name = 1;
   */
  tableLeftName = "";

  /**
   * @generated from field: string table_right_name = 2;
   */
  tableRightName = "";

  /**
   * @generated from field: string association_table_name = 3;
   */
  associationTableName = "";

  /**
   * @generated from field: string column_name_to_join_on_left = 4;
   */
  columnNameToJoinOnLeft = "";

  /**
   * @generated from field: string column_name_to_join_on_right = 5;
   */
  columnNameToJoinOnRight = "";

  /**
   * @generated from field: string link_name_table_left_to_table_right = 6;
   */
  linkNameTableLeftToTableRight = "";

  /**
   * @generated from field: string link_name_table_right_to_table_left = 7;
   */
  linkNameTableRightToTableLeft = "";

  constructor(data?: PartialMessage<RelationshipManyToMany>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "RelationshipManyToMany";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "table_left_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 2, name: "table_right_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 3, name: "association_table_name", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 4, name: "column_name_to_join_on_left", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 5, name: "column_name_to_join_on_right", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 6, name: "link_name_table_left_to_table_right", kind: "scalar", T: 9 /* ScalarType.STRING */ },
    { no: 7, name: "link_name_table_right_to_table_left", kind: "scalar", T: 9 /* ScalarType.STRING */ },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): RelationshipManyToMany {
    return new RelationshipManyToMany().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): RelationshipManyToMany {
    return new RelationshipManyToMany().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): RelationshipManyToMany {
    return new RelationshipManyToMany().fromJsonString(jsonString, options);
  }

  static equals(a: RelationshipManyToMany | PlainMessage<RelationshipManyToMany> | undefined, b: RelationshipManyToMany | PlainMessage<RelationshipManyToMany> | undefined): boolean {
    return proto3.util.equals(RelationshipManyToMany, a, b);
  }
}

/**
 * @generated from message UserDataStructure
 */
export class UserDataStructure extends Message<UserDataStructure> {
  /**
   * @generated from field: map<string, TableStructure> tables = 1;
   */
  tables: { [key: string]: TableStructure } = {};

  /**
   * @generated from field: repeated RelationshipOneToOne relationships_one_to_one = 2;
   */
  relationshipsOneToOne: RelationshipOneToOne[] = [];

  /**
   * @generated from field: repeated RelationshipOneToMany relationships_one_to_many = 3;
   */
  relationshipsOneToMany: RelationshipOneToMany[] = [];

  /**
   * @generated from field: repeated RelationshipManyToMany relationships_many_to_many = 4;
   */
  relationshipsManyToMany: RelationshipManyToMany[] = [];

  constructor(data?: PartialMessage<UserDataStructure>) {
    super();
    proto3.util.initPartial(data, this);
  }

  static readonly runtime = proto3;
  static readonly typeName = "UserDataStructure";
  static readonly fields: FieldList = proto3.util.newFieldList(() => [
    { no: 1, name: "tables", kind: "map", K: 9 /* ScalarType.STRING */, V: {kind: "message", T: TableStructure} },
    { no: 2, name: "relationships_one_to_one", kind: "message", T: RelationshipOneToOne, repeated: true },
    { no: 3, name: "relationships_one_to_many", kind: "message", T: RelationshipOneToMany, repeated: true },
    { no: 4, name: "relationships_many_to_many", kind: "message", T: RelationshipManyToMany, repeated: true },
  ]);

  static fromBinary(bytes: Uint8Array, options?: Partial<BinaryReadOptions>): UserDataStructure {
    return new UserDataStructure().fromBinary(bytes, options);
  }

  static fromJson(jsonValue: JsonValue, options?: Partial<JsonReadOptions>): UserDataStructure {
    return new UserDataStructure().fromJson(jsonValue, options);
  }

  static fromJsonString(jsonString: string, options?: Partial<JsonReadOptions>): UserDataStructure {
    return new UserDataStructure().fromJsonString(jsonString, options);
  }

  static equals(a: UserDataStructure | PlainMessage<UserDataStructure> | undefined, b: UserDataStructure | PlainMessage<UserDataStructure> | undefined): boolean {
    return proto3.util.equals(UserDataStructure, a, b);
  }
}

